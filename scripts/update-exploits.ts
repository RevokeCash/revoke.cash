import fs from 'fs/promises';
import type { RiskFactor, SpenderRiskData } from 'lib/interfaces';
import type { Exploit } from 'lib/utils/exploits';
import path from 'path';
import { getAddress } from 'viem';

const [_node, _file, exploitRepoPathRelative, dataRepoPathRelative] = process.argv;

const exploitRepoPath = path.join(process.cwd(), exploitRepoPathRelative);
const dataRepoPath = path.join(process.cwd(), dataRepoPathRelative);

const updateExploits = async () => {
  const exploits = await fs.readdir(path.join(exploitRepoPath, 'exploits'));
  const slugs = exploits.map((fn) => fn.replace('.json', ''));

  await Promise.all(
    slugs.map(async (slug) => {
      const exploitJson = await readExploit(slug);

      await Promise.all([
        lintExploit(slug, exploitJson),
        updateExploitMdDescription(slug, exploitJson),
        addExploitLabelsToSpenders(exploitJson),
      ]);
    }),
  );

  await fs.writeFile(path.join(exploitRepoPath, 'index.json'), `${JSON.stringify(slugs, null, 2)}\n`);
};

const readExploit = async (slug: string): Promise<Exploit> => {
  const exploitPath = path.join(exploitRepoPath, 'exploits', `${slug}.json`);
  const exploitContents = await fs.readFile(exploitPath, 'utf-8');
  const exploitJson = JSON.parse(exploitContents);
  return exploitJson;
};

const lintExploit = async (slug: string, json: Exploit) => {
  const exploitPath = path.join(exploitRepoPath, 'exploits', `${slug}.json`);

  const lintedAddresses = json.addresses.map(({ chainId, address }) => ({
    chainId,
    address: getAddress(address.toLowerCase()),
  }));

  const lintedExploitJson = {
    ...json,
    addresses: lintedAddresses,
  };

  await fs.writeFile(exploitPath, `${JSON.stringify(lintedExploitJson, null, 2)}\n`);
};

const updateExploitMdDescription = async (slug: string, json: Exploit) => {
  const exploitPath = path.join(__dirname, '..', 'content', 'en', 'exploits', 'short', `${slug}.md`);
  await fs.writeFile(exploitPath, `${json.description}\n`);
};

const addExploitLabelsToSpenders = async (exploit: Exploit) => {
  const spendersPath = path.join(dataRepoPath, 'data', 'manual', 'spenders');

  await Promise.all(
    exploit.addresses.map(async ({ chainId, address }) => {
      const spenderPath = path.join(spendersPath, String(chainId), `${address}.json`);

      let spenderContents: SpenderRiskData = {};
      try {
        spenderContents = JSON.parse(await fs.readFile(spenderPath, 'utf-8'));
      } catch {
        // ignore
      }

      // Remove the risk factor if it exists
      const riskFactors = (spenderContents.riskFactors ?? []).filter(
        (factor: RiskFactor) => !(factor.type === 'exploit' && factor.data === exploit.name),
      );

      // Re-add the risk factor if it's not fixed
      if (!exploit.fixed) {
        riskFactors.push({ type: 'exploit', source: 'whois', data: exploit.name });
      }

      spenderContents.riskFactors = riskFactors;

      await fs.mkdir(path.dirname(spenderPath), { recursive: true });
      await fs.writeFile(spenderPath, `${JSON.stringify(spenderContents, null, 2)}\n`);
    }),
  );
};

updateExploits();
